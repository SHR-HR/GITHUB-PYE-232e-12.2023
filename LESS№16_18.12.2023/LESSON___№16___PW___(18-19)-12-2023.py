# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
''''  ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
Дата выполнения практической работы: 18-19 - ДЕКАБРЯ 2023
''''  ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
'''
Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
Дисциплина: Основы программирования на Python
'''
'''
Урок от 18.12.2023
Практическая работа №16: 16: Обработка исключений. Собственные исключения
'''
'''
                        ИЗ-ЗА ТЕМПЕРАТУРЫ, Я ВЫНУЖДЕН ОГРАНИЧИТЬСЯ ТОЛЬКО 1 - ПРИМЕРОМ НАПИСАНИЯ КОДА
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №1.

Напишите программу, которая запрашивает ввод двух значений. Если хотя бы одно из них не является числом,
то должна выполняться конкатенация, то есть соединение, строк. В остальных случаях введенные числа суммируются.

Примеры выполнения программы:

pl@pl-desk:~$ python3 test.py
Первое значение: 4
Второе значение: 5
Результат: 9.0
pl@pl-desk:~$ python3 test.py
Первое значение: a
Второе значение: 9
Результат: a9

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

Задание №2.

Напишите программу, в которой я ввожу трехзначное число. Найти сумму, произведение его цифр.
В случае ввода текста, или деления на 0 выведите сообщение.

Input: 351 
Output: 9 
Input: 0
Output: Error. You can’t divide on zero

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


Задание №3.

Заданы две клетки шахматной доски. 
Если они покрашены в один цвет, то выведите слово YES, а если в разные цвета — то NO.

Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для 
первой клетки, потом для второй клетки.

Требуется определить, бьет ли ладья, стоящая на клетке с указанными координатами 
(номер строки и номер столбца), фигуру, стоящую на другой указанной клетке.

Вводятся четыре числа: координаты ладьи (два числа) и координаты другой фигуры (два числа),
каждое число вводится в отдельной строке. Координаты - целые числа в интервале от 1 до 8.

Требуется вывести слово YES, если ладья сможет побить фигуру за 1 ход и NO - в противном случае.
Ладья ходит по прямым линиям (горизонтальным и вертикальным).

Input:                  Input:
1 1 2 2                 нажали клавишу Enter
Output:                 Output:
NO                      Error, try again Input:

Input:
text                    нажали клавишу Enter
Output:                 Output:
Error, try again        Error, out of range

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


Задание №4.

Дополните предыдущий код, фигурой короля и его действиями.
Создайте диалог с пользователем, узнайте какой из фигур будет выполнять ход игрок.

Шахматный король ходит по горизонтали, вертикали и диагонали, но только на 1 клетку.
Даны две различные клетки шахматной доски, определите, может ли король попасть с первой клетки на вторую одним ходом.

Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для 
первой клетки, потом для второй клетки.

Программа должна вывести YES, если из первой клетки ходом короля можно попасть во вторую или NO в противном случае.
Обработайте все исключения, которые могут встретиться в программе.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

Выполните следующие задания:


Задание №1.

Программа написана верно, однако содержат места потенциальных ошибок.

Для каждой задачи:

найдите потенциальные источники ошибок (укажите номера строк в строке документации);
используя конструкцию try добавьте в код обработку соответствующих исключений.

Исходная программа:
def avg(a, b):
    return (a * b) ** 0.5
    
a = float(input("a = "))
b = float(input("b = "))
c = avg(a, b)
print("Среднее геометрическое = {:.2f}".format(c))

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


Задание №2.

Римское число
Создайте класс Roman (РимскоеЧисло), представляющий римское число и поддерживающий операции +, -, *, /.

При реализации класса:

операции +, -, *, / реализуйте как специальные методы
методы преобразования как статические методы.
Опишите все исключения, возможные в программе. (Например, неверный вод, ошибка деления на 0).

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

Выполните следующие задания:

Задание №1.

Создайте собственное исключение, которое будет вызываться в случае, если в функцию check_name() передано имя 
длиннее четырёх символов.

Подсказка:
Создайте класс исключения, наследующийся от другого класса исключения.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

Задание №2

Банк предлагает ряд вкладов для физических лиц:

Срочный вклад: расчет прибыли осуществляется по формуле простых процентов;

Бонусный вклад: бонус начисляется в конце периода как % от прибыли, если вклад больше определенной суммы;

Вклад с капитализацией процентов.
Реализуйте приложение, которое бы позволило подобрать клиенту вклад по заданным параметрам.

Опишите все исключения, возможные в программе. (Например, неверный вод, ошибка деления на 0 и т.д.).
'''
'''
Решения:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №1.

Напишите программу, которая запрашивает ввод двух значений. Если хотя бы одно из них не является числом,
то должна выполняться конкатенация, то есть соединение, строк. В остальных случаях введенные числа суммируются.

Примеры выполнения программы:

pl@pl-desk:~$ python3 test.py
Первое значение: 4
Второе значение: 5
Результат: 9.0
pl@pl-desk:~$ python3 test.py
Первое значение: a
Второе значение: 9
Результат: a9
'''
while True:
    try:
        first_value = input("Первое значение: ")
        second_value = input("Второе значение: ")

        # Пытаемся преобразовать введенные значения в числа
        first_value = float(first_value)
        second_value = float(second_value)

        # Если успешно, суммируем числа и выводим результат
        result = first_value + second_value
        print(f"Результат: {result}")
        break

    except ValueError:
        # Если хотя бы одно из значений не является числом,
        # выполняем конкатенацию строк и выводим результат
        result = str(first_value) + str(second_value)
        print(f"Результат: {result}")
        break
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Шаги:

1. Бесконечный цикл: while True создает бесконечный цикл, который будет выполняться до тех пор,
пока не будет принудительно прерван инструкцией break.

2. Запрос ввода значений: first_value и second_value запрашивают у пользователя ввод двух значений.

3. Преобразование в числа: float(first_value) и float(second_value) пытаются преобразовать введенные значения в 
числа типа float. Если пользователь ввел корректные числа, программа переходит к следующему шагу. 
Если хотя бы одно из значений не может быть преобразовано в число (возникает исключение ValueError), 
программа переходит в блок except.

4. Суммирование чисел: Если преобразование в числа прошло успешно, программа суммирует числа и выводит результат.

5. Обработка исключения: Если возникает ValueError (т.е., хотя бы одно из значений не является числом),
программа переходит в блок except. Здесь значения конкатенируются в строки (str(first_value) + str(second_value)) и
результат выводится.

6. Прерывание цикла: Инструкция break прерывает выполнение цикла, завершая программу после ввода и обработки значений.


Таким образом, при 100% выполнении задания вам нужно:
• Ввести два значения.
• Если оба значения являются числами, программа выведет их сумму.
• Если хотя бы одно из значений не является числом, программа выведет результат конкатенации строк.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №2.

Напишите программу, в которой я ввожу трехзначное число. Найти сумму, произведение его цифр.
В случае ввода текста, или деления на 0 выведите сообщение.

Input: 351 
Output: 9 
Input: 0
Output: Error. You can’t divide on zero
'''
while True:
    try:
        # Ввод трехзначного числа
        num = input("Введите трехзначное число: ")

        # Проверка на корректность ввода
        if not num.isdigit() or len(num) != 3:
            raise ValueError("Введите корректное трехзначное число")

        # Преобразование ввода в целое число
        num = int(num)

        # Проверка на деление на ноль
        if any(digit == 0 for digit in [int(d) for d in str(num)]):
            raise ZeroDivisionError("Нельзя делить на ноль.")

        # Разбиение числа на цифры
        digit1 = num // 100
        digit2 = (num // 10) % 10
        digit3 = num % 10

        # Вычисление суммы и произведения цифр
        digit_sum = digit1 + digit2 + digit3
        digit_product = digit1 * digit2 * digit3

        # Вывод результатов
        print("Сумма цифр:", digit_sum)
        print("Произведение цифр:", digit_product)
        break

    except ValueError as e:
        print(f"Ошибка: {e}")
    except ZeroDivisionError as e:
        print(f"Ошибка: {e}")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Шаги:

1. Бесконечный цикл: while True создает бесконечный цикл, который будет выполняться до тех пор, пока не будет
принудительно прерван инструкцией break.

2. Ввод трехзначного числа: num = input("Введите трехзначное число: ") запрашивает у пользователя ввод
трехзначного числа.

3. Проверка на корректность ввода: if not num.isdigit() or len(num) != 3: проверяет, является ли введенное значение
числом и имеет ли оно три цифры. Если нет, возникает исключение ValueError.

4. Преобразование ввода в целое число: num = int(num) преобразует введенное значение в целое число.

5. Проверка на деление на ноль: if any(digit == 0 for digit in [int(d) for d in str(num)]) проверяет, есть ли в 
числе хотя бы один ноль. Если есть, возникает исключение ZeroDivisionError.

6. Разбиение числа на цифры: digit1, digit2 и digit3 получают цифры из трехзначного числа.

7. Вычисление суммы и произведения цифр: digit_sum = digit1 + digit2 + digit3 и digit_product = digit1 * digit2 * digit3 
вычисляют сумму и произведение цифр.

8. Вывод результатов: print("Сумма цифр:", digit_sum) и print("Произведение цифр:", digit_product) выводят результаты.

9. Прерывание цикла: Инструкция break прерывает выполнение цикла, завершая программу после ввода и обработки значений.


Таким образом, при 100% выполнении задания вам нужно:
• Ввести трехзначное число.
• Программа проверит его корректность, вычислит сумму и произведение цифр.
• Если произойдет ошибка (например, ввод текста вместо числа или деление на ноль), программа выведет соответствующее
сообщение.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №3.

Заданы две клетки шахматной доски. 
Если они покрашены в один цвет, то выведите слово YES, а если в разные цвета — то NO.

Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для 
первой клетки, потом для второй клетки.

Требуется определить, бьет ли ладья, стоящая на клетке с указанными координатами 
(номер строки и номер столбца), фигуру, стоящую на другой указанной клетке.

Вводятся четыре числа: координаты ладьи (два числа) и координаты другой фигуры (два числа),
каждое число вводится в отдельной строке. Координаты - целые числа в интервале от 1 до 8.

Требуется вывести слово YES, если ладья сможет побить фигуру за 1 ход и NO - в противном случае.
Ладья ходит по прямым линиям (горизонтальным и вертикальным).

Input:                  Input:
1 1 2 2                 нажали клавишу Enter
Output:                 Output:
NO                      Error, try again Input:

Input:
text                    нажали клавишу Enter
Output:                 Output:
Error, try again        Error, out of range
'''
while True:
    try:
        # Ввод координат ладьи
        row1 = int(input("Введите номер строки для ладьи: "))
        col1 = int(input("Введите номер столбца для ладьи: "))

        # Ввод координат другой фигуры
        row2 = int(input("Введите номер строки для другой фигуры: "))
        col2 = int(input("Введите номер столбца для другой фигуры: "))

        # Проверка ввода на соответствие интервалу от 1 до 8
        if not (1 <= row1 <= 8) or not (1 <= col1 <= 8) or not (1 <= row2 <= 8) or not (1 <= col2 <= 8):
            raise ValueError("Координаты должны быть в интервале от 1 до 8")

        # Проверка на одинаковый цвет клеток
        is_same_color = (row1 + col1) % 2 == (row2 + col2) % 2

        # Вывод результата
        if is_same_color:
            print("YES")
        else:
            print("NO")
        break

    except ValueError as e:
        print(f"Ошибка: {e}")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Шаги:

1. Бесконечный цикл: while True создает бесконечный цикл, который будет выполняться до тех пор,
пока не будет принудительно прерван инструкцией break.

2. Ввод координат: row1, col1, row2, col2 - это переменные, которые хранят ввод пользователя для координат ладьи
и другой фигуры.

3. Проверка ввода на соответствие интервалу от 1 до 8: if not (1 <= row1 <= 8) or not (1 <= col1 <= 8) or 
not (1 <= row2 <= 8) or not (1 <= col2 <= 8): проверяет, что введенные значения находятся в диапазоне от 1 до 8.
Если ввод не соответствует требованиям, генерируется исключение ValueError.

4. Проверка на одинаковый цвет клеток: is_same_color = (row1 + col1) % 2 == (row2 + col2) % 2 определяет, 
находятся ли клетки на одинаковом цвете. Шахматная доска имеет чередующиеся цвета, и это условие проверяет, 
находятся ли обе клетки на белых или черных полях.

5. Вывод результата: В зависимости от результата проверки, программа выводит "YES" 
(если клетки одного цвета) или "NO" (если клетки разного цвета).

6. Прерывание цикла: Инструкция break прерывает выполнение цикла, завершая программу после ввода и обработки значений.


Таким образом, при 100% выполнении задания вам нужно:
• Ввести координаты ладьи (номер строки и номер столбца).
• Ввести координаты другой фигуры (также номер строки и номер столбца).
• Программа проверит, находятся ли эти клетки на одинаковом цвете и выведет "YES" или "NO" в зависимости от результата.
• Если ввод не соответствует требованиям (например, введены не числа или числа не в интервале от 1 до 8),
программа выдаст сообщение об ошибке и предложит ввести данные заново.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №4.

Дополните предыдущий код, фигурой короля и его действиями.
Создайте диалог с пользователем, узнайте какой из фигур будет выполнять ход игрок.

Шахматный король ходит по горизонтали, вертикали и диагонали, но только на 1 клетку.
Даны две различные клетки шахматной доски, определите, может ли король попасть с первой клетки на вторую одним ходом.

Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для 
первой клетки, потом для второй клетки.

Программа должна вывести YES, если из первой клетки ходом короля можно попасть во вторую или NO в противном случае.
Обработайте все исключения, которые могут встретиться в программе.
'''
def is_king_move_possible(row1, col1, row2, col2):
    # Проверка возможности хода короля
    return abs(row1 - row2) <= 1 and abs(col1 - col2) <= 1


while True:
    try:
        # Диалог с пользователем для выбора фигуры
        piece = input("Выберите фигуру (ладья/король): ").lower()

        if piece not in ('ладья', 'король'):
            raise ValueError("Выберите корректную фигуру (ладья/король)")

        # Ввод координат
        row1 = int(input("Введите номер строки для фигуры: "))
        col1 = int(input("Введите номер столбца для фигуры: "))
        row2 = int(input("Введите номер строки для другой клетки: "))
        col2 = int(input("Введите номер столбца для другой клетки: "))

        # Проверка ввода на соответствие интервалу от 1 до 8
        if not (1 <= row1 <= 8) or not (1 <= col1 <= 8) or not (1 <= row2 <= 8) or not (1 <= col2 <= 8):
            raise ValueError("Координаты должны быть в интервале от 1 до 8")

        # Проверка возможности хода
        if piece == 'ладья':
            # Проверка на одинаковый цвет клеток
            is_same_color = (row1 + col1) % 2 == (row2 + col2) % 2

            # Вывод результата
            if is_same_color:
                print("YES")
            else:
                print("NO")

        elif piece == 'король':
            # Проверка возможности хода короля
            if is_king_move_possible(row1, col1, row2, col2):
                print("YES")
            else:
                print("NO")

        break

    except ValueError as e:
        print(f"Ошибка: {e}")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Шаги:

1. Определение функции is_king_move_possible: Эта функция принимает координаты двух клеток и возвращает True,
если король может попасть с одной клетки на другую за один ход, и False в противном случае. 
Проверка выполняется по горизонтали, вертикали и диагонали.

2. Бесконечный цикл: while True создает бесконечный цикл, который будет выполняться до тех пор, 
пока не будет принудительно прерван инструкцией break.

3. Диалог с пользователем: piece = input("Выберите фигуру (ладья/король): ").lower() запрашивает у пользователя
выбор фигуры (ладьи или короля). Введенный текст приводится к нижнему регистру для удобства сравнения.

4. Проверка выбора фигуры: if piece not in ('ладья', 'король'): проверяет, является ли выбор пользователя корректным.

5. Ввод координат: Пользователь вводит координаты для фигуры и клетки.

6. Проверка ввода на соответствие интервалу: if not (1 <= row1 <= 8) or not (1 <= col1 <= 8) or not (1 <= row2 <= 8) or
not (1 <= col2 <= 8): проверяет, что введенные значения находятся в диапазоне от 1 до 8.

7. Проверка возможности хода: В зависимости от выбора фигуры (piece), программа выполняет различные проверки.
Для ладьи проверяется одинаковый цвет клеток, для короля — возможность хода.

8. Вывод результата: Программа выводит "YES", если ход возможен, и "NO" в противном случае.

9. Прерывание цикла: Инструкция break прерывает выполнение цикла, завершая программу после ввода и обработки значений.


Таким образом, при 100% выполнении задания вам нужно:
• Выбрать фигуру (ладья или король).
• Ввести координаты для фигуры и клетки.
• Программа проверит возможность хода в зависимости от выбранной фигуры и выведет "YES" или "NO".
• Если ввод не соответствует требованиям (например, введены не числа или числа не в интервале от 1 до 8), 
программа выдаст сообщение об ошибке и предложит ввести данные заново.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
        '''                         ЧТО-ТО У МЕНЯ ПОШЛО НЕ ТАК..................                         '''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
import pygame
import sys

pygame.init()

BOARD_SIZE = 8
CELL_SIZE = 80

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)

screen = pygame.display.set_mode((BOARD_SIZE * CELL_SIZE, BOARD_SIZE * CELL_SIZE))
pygame.display.set_caption("Шахматы")

def draw_board():
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE))

def draw_pieces(row1, col1, row2, col2):
    pygame.draw.rect(screen, RED, (col1 * CELL_SIZE, row1 * CELL_SIZE, CELL_SIZE, CELL_SIZE))
    pygame.draw.rect(screen, RED, (col2 * CELL_SIZE, row2 * CELL_SIZE, CELL_SIZE, CELL_SIZE))

def main():
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        try:
            piece = input("Выберите фигуру (ладья/король): ").lower()

            if piece not in ('ладья', 'король'):
                raise ValueError("Выберите корректную фигуру (ладья/король)")

            row1 = int(input("Введите номер строки для фигуры: "))
            col1 = int(input("Введите номер столбца для фигуры: "))
            row2 = int(input("Введите номер строки для другой клетки: "))
            col2 = int(input("Введите номер столбца для другой клетки: "))

            if (not (1 <= row1 <= BOARD_SIZE) or not (1 <= col1 <= BOARD_SIZE) or not (1 <= row2 <= BOARD_SIZE) or
                    not (1 <= col2 <= BOARD_SIZE)):
                raise ValueError(f"Координаты должны быть в интервале от 1 до {BOARD_SIZE}")

            screen.fill(WHITE)
            draw_board()
            draw_pieces(row1 - 1, col1 - 1, row2 - 1, col2 - 1)

            pygame.display.flip()

            pygame.time.delay(1000)

        except ValueError as e:
            print(f"Ошибка: {e}")

if __name__ == "__main__":
    main()
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''

1. Импорт библиотек:

import pygame
import sys

Здесь мы импортируем библиотеку Pygame и модуль sys.
Pygame используется для создания графического интерфейса, а sys - для выхода из программы.


2. Инициализация Pygame:

pygame.init()

Эта строка инициализирует Pygame и его модули. Она должна вызываться перед использованием любых функций Pygame.


3. Определение констант:

BOARD_SIZE = 8
CELL_SIZE = 80

Здесь определены константы для размера доски и размера клетки.


4. Определение цветов:

WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)

Здесь определены цвета в формате RGB (красный, зеленый, синий).

5. Создание окна:

screen = pygame.display.set_mode((BOARD_SIZE * CELL_SIZE, BOARD_SIZE * CELL_SIZE))
pygame.display.set_caption("Шахматы")

Здесь создается окно с размерами, зависящими от размера доски, и устанавливается заголовок окна.


6. Функция отрисовки доски:

def draw_board():
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            color = WHITE if (row + col) % 2 == 0 else BLACK
            pygame.draw.rect(screen, color, (col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE))

Эта функция отрисовывает шахматную доску, заполняя четные и нечетные клетки разными цветами.


7. Функция отрисовки фигур:

def draw_pieces(row1, col1, row2, col2):
    pygame.draw.rect(screen, RED, (col1 * CELL_SIZE, row1 * CELL_SIZE, CELL_SIZE, CELL_SIZE))
    pygame.draw.rect(screen, RED, (col2 * CELL_SIZE, row2 * CELL_SIZE, CELL_SIZE, CELL_SIZE))

Эта функция отрисовывает красные квадраты для фигур в указанных координатах.


8. Основной цикл программы:

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

В этом бесконечном цикле мы проверяем события Pygame, и если событие "QUIT" (закрытие окна), то программа завершается.


9. Пользовательский ввод и визуализация:

try:
    # ... (ваш код для ввода координат и выбора фигуры)

    screen.fill(WHITE)
    draw_board()
    draw_pieces(row1 - 1, col1 - 1, row2 - 1, col2 - 1)

    pygame.display.flip()

    pygame.time.delay(1000)
except ValueError as e:
    print(f"Ошибка: {e}")

Этот код находится внутри бесконечного цикла. В блоке try пользователь вводит координаты и выбирает фигуру. 
Затем программа очищает экран, рисует доску и фигуры, обновляет дисплей Pygame и делает задержку в 1 
секунду для визуализации.


11. Завершение программы:

Это условие выполняется, когда скрипт запускается напрямую, а не импортируется как модуль. 
Функция main() запускается, и программа начинает выполнение.


Чтобы успешно выполнить задание:
• Запустите код и введите координаты для фигур. Убедитесь, что окно Pygame отображается.
• Визуально убедитесь, что фигуры правильно расположены на доске в соответствии с введенными координатами.
• Закройте окно Pygame, чтобы завершить программу.
'''
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
'''
Выполните следующие задания:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №1.

Программа написана верно, однако содержат места потенциальных ошибок.

Для каждой задачи:

найдите потенциальные источники ошибок (укажите номера строк в строке документации);
используя конструкцию try добавьте в код обработку соответствующих исключений.

Исходная программа:
def avg(a, b):
    return (a * b) ** 0.5
    
a = float(input("a = "))
b = float(input("b = "))
c = avg(a, b)
print("Среднее геометрическое = {:.2f}".format(c))
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Исходная программа:
'''
def avg(a, b):
    return (a * b) ** 0.5

a = float(input("a = "))
b = float(input("b = "))
c = avg(a, b)
print("Среднее геометрическое = {:.2f}".format(c))
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Потенциальные источники ошибок:
'''
'''
Проблема:
            Пользователь может ввести нечисловое значение.
'''
a = float(input("a = "))
b = float(input("b = "))
'''
Обработка исключений:
'''
try:
    a = float(input("a = "))
    b = float(input("b = "))
except ValueError:
    print("Ошибка ввода. Введите числовое значение.")
    # Дополнительные действия, если необходимо, например, повторный запрос ввода.
    sys.exit(1)  # Выход из программы с кодом ошибки.

try:
    c = avg(a, b)
except ZeroDivisionError:
    print("Ошибка: деление на ноль.")
    sys.exit(1)
except ValueError:
    print("Ошибка: неверный тип аргумента для функции avg.")
    sys.exit(1)

print("Среднее геометрическое = {:.2f}".format(c))
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №2.

Римское число
Создайте класс Roman (РимскоеЧисло), представляющий римское число и поддерживающий операции +, -, *, /.

При реализации класса:

операции +, -, *, / реализуйте как специальные методы
методы преобразования как статические методы.
Опишите все исключения, возможные в программе. (Например, неверный вод, ошибка деления на 0).
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Класс Roman: https://www.youtube.com/watch?v=hcRlypUPvGI
'''
class Roman:
    def __init__(self, value):
        # Реализация инициализации объекта Roman
        pass

    def __add__(self, other):
        # Реализация сложения
        pass

    def __sub__(self, other):
        # Реализация вычитания
        pass

    def __mul__(self, other):
        # Реализация умножения
        pass

    def __truediv__(self, other):
        # Реализация деления
        pass

    @staticmethod
    def to_roman(number):
        # Реализация преобразования в римское число
        pass

    @staticmethod
    def from_roman(roman):
        # Реализация преобразования из римского числа
        pass
''''
Исключения:
''''
'''
Ошибка ввода:
                Если введено неверное римское число или неверное арабское число.
'''
@staticmethod
def to_roman(number):
    try:
        # ... (ваша реализация преобразования)
    except ValueError as e:
        raise ValueError(f"Ошибка ввода: {e}")
@staticmethod
def from_roman(roman):
    # ... (ваша реализация преобразования)
    if not is_valid_roman(roman):
        raise ValueError("Ошибка ввода: неверное римское число.")
'''
Здесь is_valid_roman - это функция, которая проверяет корректность римского числа. Можете написать ее самостоятельно.
'''
'''
Ошибка деления на 0:
                        Если делитель (знаменатель) в операции деления равен 0.
'''
def __truediv__(self, other):
    if other == 0:
        raise ValueError("Ошибка: деление на ноль.")
    # ... (ваша реализация деления)
'''
Пример использования:
'''
# Создаем объекты Roman
num1 = Roman.from_roman("X")
num2 = Roman(5)

# Производим операции
result_add = num1 + num2
result_sub = num1 - num2
result_mul = num1 * num2

try:
    result_div = num1 / 0  # Вызовет исключение деления на 0
except ValueError as e:
    print(e)
'''
Ошибка другой операции:
                        Если операция не поддерживается (например, операция возведения в степень).
'''
def __pow__(self, other):
    raise NotImplementedError("Ошибка: операция не поддерживается.")
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

Выполните следующие задания:

Задание №1.

Создайте собственное исключение, которое будет вызываться в случае, если в функцию check_name() передано имя 
длиннее четырёх символов.

Подсказка:
Создайте класс исключения, наследующийся от другого класса исключения.
'''


# Создаем новый класс исключения, который наследуется от ValueError
class NameTooLongError(ValueError):
    pass


# Определяем функцию check_name, которая проверяет длину переданного имени
def check_name(name):
    if len(name) > 4:
        # Если имя длиннее 4 символов, вызываем исключение NameTooLongError
        raise NameTooLongError("Имя не должно быть длиннее четырех символов")


# Пример использования
try:
    # Пользователь вводит имя
    user_name = input("Введите имя: ")

    # Вызываем функцию check_name, которая может вызвать исключение NameTooLongError
    check_name(user_name)

    # Если функция прошла успешно (без исключения), выводим сообщение об успешной проверке
    print(f"Имя '{user_name}' прошло проверку.")
except NameTooLongError as e:
    # Если было вызвано исключение NameTooLongError, выводим сообщение об ошибке
    print(f"Ошибка: {e}")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
1. Создание класса исключения: к примеру, пусть будет такое
'''
class NameTooLongError(ValueError):
    pass
'''
Здесь создается новый класс исключения NameTooLongError, который наследуется от встроенного класса ValueError.
Этот класс будет использоваться для обработки конкретной ошибки - слишком длинного имени.
'''
'''
2. Определение функции check_name:
'''
def check_name(name):
    if len(name) > 4:
        raise NameTooLongError("Имя не должно быть длиннее четырех символов")
'''
Определяется функция check_name, которая принимает имя в качестве аргумента. 
Если длина имени больше 4 символов, функция вызывает исключение NameTooLongError с соответствующим сообщением.
'''
'''
3. Пример использования:
'''
try:
    user_name = input("Введите имя: ")
    check_name(user_name)
    print(f"Имя '{user_name}' прошло проверку.")
except NameTooLongError as e:
    print(f"Ошибка: {e}")
'''
В блоке try пользователь вводит имя, затем вызывается функция check_name для проверки имени.
Если имя проходит проверку, выводится сообщение об успешной проверке.
Если имя слишком длинное и вызывается исключение NameTooLongError, программа переходит в блок except,
где выводится сообщение об ошибке.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Задание №2

Банк предлагает ряд вкладов для физических лиц:

Срочный вклад: расчет прибыли осуществляется по формуле простых процентов;

Бонусный вклад: бонус начисляется в конце периода как % от прибыли, если вклад больше определенной суммы;

Вклад с капитализацией процентов.
Реализуйте приложение, которое бы позволило подобрать клиенту вклад по заданным параметрам.

Опишите все исключения, возможные в программе. (Например, неверный вод, ошибка деления на 0 и т.д.).
'''
class BankDeposit:
    def __init__(self, amount, period, interest_rate):
        self.amount = amount
        self.period = period
        self.interest_rate = interest_rate

    def calculate_profit(self):
        # Общий расчет прибыли, метод может быть переопределен в подклассах
        return (self.amount * self.interest_rate * self.period) / 100

class TermDeposit(BankDeposit):
    def __init__(self, amount, period, interest_rate):
        super().__init__(amount, period, interest_rate)

    def calculate_profit(self):
        # Расчет прибыли для срочного вклада (простые проценты)
        return super().calculate_profit()

class BonusDeposit(BankDeposit):
    def __init__(self, amount, period, interest_rate, bonus_threshold, bonus_rate):
        super().__init__(amount, period, interest_rate)
        self.bonus_threshold = bonus_threshold
        self.bonus_rate = bonus_rate

    def calculate_profit(self):
        # Расчет прибыли для бонусного вклада (с бонусом)
        profit = super().calculate_profit()
        if self.amount >= self.bonus_threshold:
            profit += (self.amount * self.bonus_rate) / 100
        return profit

class CompoundDeposit(BankDeposit):
    def __init__(self, amount, period, interest_rate, compound_frequency):
        super().__init__(amount, period, interest_rate)
        self.compound_frequency = compound_frequency

    def calculate_profit(self):
        # Расчет прибыли для вклада с капитализацией процентов
        compound_factor = 1 + self.interest_rate / (100 * self.compound_frequency)
        return self.amount * (compound_factor ** (self.compound_frequency * self.period)) - self.amount

# Пример использования:

try:
    # Получаем данные от пользователя
    amount = float(input("Введите сумму вклада: "))
    period = int(input("Введите срок вклада (в месяцах): "))
    interest_rate = float(input("Введите годовую процентную ставку: "))

    # Создаем экземпляры различных вкладов
    term_deposit = TermDeposit(amount, period, interest_rate)
    bonus_threshold = float(input("Введите порог для бонусного вклада: "))
    bonus_rate = float(input("Введите процент бонуса: "))
    bonus_deposit = BonusDeposit(amount, period, interest_rate, bonus_threshold, bonus_rate)
    compound_frequency = int(input("Введите частоту капитализации процентов (в месяцах): "))
    compound_deposit = CompoundDeposit(amount, period, interest_rate, compound_frequency)

    # Рассчитываем и выводим прибыль для каждого вклада
    print(f"Прибыль для срочного вклада: {term_deposit.calculate_profit()}")
    print(f"Прибыль для бонусного вклада: {bonus_deposit.calculate_profit()}")
    print(f"Прибыль для вклада с капитализацией: {compound_deposit.calculate_profit()}")

except ValueError as e:
    print(f"Ошибка ввода: {e}")
except ZeroDivisionError:
    print("Ошибка: деление на ноль.")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Исключения:
'''
'''
1. Ошибка ввода:
                    Если введены некорректные значения (например, нечисловые значения).
'''
amount = float(input("Введите сумму вклада: "))
period = int(input("Введите срок вклада (в месяцах): "))
interest_rate = float(input("Введите годовую процентную ставку: "))
bonus_threshold = float(input("Введите порог для бонусного вклада: "))
bonus_rate = float(input("Введите процент бонуса: "))
compound_frequency = int(input("Введите частоту капитализации процентов (в месяцах): "))
'''
2. Ошибка деления на 0:
                        Если введена нулевая частота капитализации процентов.
'''
compound_frequency = int(input("Введите частоту капитализации процентов (в месяцах): "))
if compound_frequency == 0:
    raise ValueError("Ошибка: частота капитализации не может быть равной нулю.")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Шаг 1: Определение класса BankDeposit

Здесь определен базовый класс BankDeposit, который представляет собой общий вклад в банке.
У него есть атрибуты: amount (сумма вклада), period (срок вклада в месяцах), и interest_rate 
(годовая процентная ставка). Также есть метод calculate_profit, который рассчитывает общую прибыль для вклада.
'''
class BankDeposit:
    def __init__(self, amount, period, interest_rate):
        self.amount = amount
        self.period = period
        self.interest_rate = interest_rate

    def calculate_profit(self):
        # Общий расчет прибыли, метод может быть переопределен в подклассах
        return (self.amount * self.interest_rate * self.period) / 100
'''
__init__ метод: Этот метод инициализирует объект класса BankDeposit атрибутами amount (сумма вклада), 
period (срок вклада в месяцах), и interest_rate (годовая процентная ставка).
calculate_profit метод: Этот метод рассчитывает общую прибыль для вклада по формуле простых процентов.
'''
'''
Шаг 2: Определение подкласса TermDeposit

Здесь создан подкласс TermDeposit, который наследуется от базового класса BankDeposit. 
Он использует все атрибуты и методы родительского класса. Метод calculate_profit в подклассе не переопределен, 
но можно было бы это сделать, если нужно было бы изменить формулу расчета прибыли.
'''
class TermDeposit(BankDeposit):
    def __init__(self, amount, period, interest_rate):
        super().__init__(amount, period, interest_rate)

    def calculate_profit(self):
        # Расчет прибыли для срочного вклада (простые проценты)
        return super().calculate_profit()
'''
__init__ метод: Этот метод вызывает __init__ метод родительского класса, чтобы унаследовать его атрибуты.
calculate_profit метод: Этот метод переопределяет метод calculate_profit родительского класса. 
В данном случае, он просто вызывает метод родительского класса для расчета прибыли.
'''
'''
Шаг 3: Определение подкласса BonusDeposit

Здесь создан подкласс BonusDeposit, который также наследуется от базового класса BankDeposit. 
В дополнение к атрибутам родительского класса, у него есть bonus_threshold (порог суммы для начисления бонуса) 
и bonus_rate (процент бонуса). Метод calculate_profit переопределен для учета бонуса при достижении порога.
'''
class BonusDeposit(BankDeposit):
    def __init__(self, amount, period, interest_rate, bonus_threshold, bonus_rate):
        super().__init__(amount, period, interest_rate)
        self.bonus_threshold = bonus_threshold
        self.bonus_rate = bonus_rate

    def calculate_profit(self):
        # Расчет прибыли для бонусного вклада (с бонусом)
        profit = super().calculate_profit()
        if self.amount >= self.bonus_threshold:
            profit += (self.amount * self.bonus_rate) / 100
        return profit
'''
__init__ метод: Этот метод вызывает __init__ метод родительского класса и 
добавляет два новых атрибута - bonus_threshold и bonus_rate.
calculate_profit метод: Этот метод переопределяет метод calculate_profit родительского класса. 
Он сначала вызывает метод родительского класса для расчета прибыли и затем добавляет бонус к прибыли, 
если сумма вклада больше или равна порогу.
'''
'''
Шаг 4: Определение подкласса CompoundDeposit

Здесь создан подкласс CompoundDeposit, также наследующийся от BankDeposit. 
У него есть дополнительный атрибут compound_frequency (частота капитализации процентов в месяцах). 
Метод calculate_profit переопределен для учета капитализации процентов.
'''
class CompoundDeposit(BankDeposit):
    def __init__(self, amount, period, interest_rate, compound_frequency):
        super().__init__(amount, period, interest_rate)
        self.compound_frequency = compound_frequency

    def calculate_profit(self):
        # Расчет прибыли для вклада с капитализацией процентов
        compound_factor = 1 + self.interest_rate / (100 * self.compound_frequency)
        return self.amount * (compound_factor ** (self.compound_frequency * self.period)) - self.amount
'''
__init__ метод: Этот метод также вызывает __init__ метод родительского класса и добавляет 
новый атрибут - compound_frequency.
calculate_profit метод: Этот метод переопределяет метод calculate_profit родительского класса.
Он рассчитывает прибыль для вклада с капитализацией процентов.
'''
'''
Шаг 5: Пример использования классов

В блоке try пользователь вводит данные для создания экземпляров различных вкладов.
В блоке except обрабатываются исключения, такие как ValueError (некорректный ввод) и ZeroDivisionError 
(деление на ноль при некорректных данных).
'''
try:
    amount = float(input("Введите сумму вклада: "))
    period = int(input("Введите срок вклада (в месяцах): "))
    interest_rate = float(input("Введите годовую процентную ставку: "))

    term_deposit = TermDeposit(amount, period, interest_rate)
    bonus_threshold = float(input("Введите порог для бонусного вклада: "))
    bonus_rate = float(input("Введите процент бонуса: "))
    bonus_deposit = BonusDeposit(amount, period, interest_rate, bonus_threshold, bonus_rate)
    compound_frequency = int(input("Введите частоту капитализации процентов (в месяцах): "))
    compound_deposit = CompoundDeposit(amount, period, interest_rate, compound_frequency)

    print(f"Прибыль для срочного вклада: {term_deposit.calculate_profit()}")
    print(f"Прибыль для бонусного вклада: {bonus_deposit.calculate_profit()}")
    print(f"Прибыль для вклада с капитализацией: {compound_deposit.calculate_profit()}")

except ValueError as e:
    print(f"Ошибка ввода: {e}")
except ZeroDivisionError:
    print("Ошибка: деление на ноль.")
'''
Ввод данных: 
Пользователь вводит сумму вклада, срок вклада, годовую процентную ставку и другие параметры для создания 
экземпляров различных вкладов.
Создание экземпляров классов: Создаются экземпляры классов TermDeposit, BonusDeposit и CompoundDeposit 
с переданными параметрами.
Расчет и вывод прибыли: 
Для каждого вклада вызывается метод calculate_profit, и результат выводится на экран.
Обработка исключений: 
В блоке except обрабатываются исключения, такие как ValueError (некорректный ввод) и ZeroDivisionError 
(деление на ноль при некорректных данных).
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

