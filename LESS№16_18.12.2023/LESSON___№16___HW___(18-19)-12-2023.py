# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
''''  ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
Дата выполнения практической работы: 18-19 - ДЕКАБРЯ 2023
''''  ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
'''
Курс: Разработка Web-приложений на Python, с применением Фреймворка Django
Дисциплина: Основы программирования на Python
'''
'''
Урок от 18.12.2023
Домашняя работа №16: 16: Обработка исключений. Собственные исключения
'''
'''
                        ИЗ-ЗА ТЕМПЕРАТУРЫ, Я ВЫНУЖДЕН ОГРАНИЧИТЬСЯ ТОЛЬКО 1 - ПРИМЕРОМ НАПИСАНИЯ КОДА
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
'''
Создайте мини-приложение «Шахматная доска».
На практическом занятие вы создали игры для шахматных фигур «Король», «Ладья».

• Дополните программу следующим действиями:
Шахматный ферзь ходит по диагонали, горизонтали или вертикали. Даны две различные клетки шахматной доски, определите,
может ли ферзь попасть с первой клетки на вторую одним ходом.
Шахматный конь ходит буквой “Г” - на две клетки по вертикали в любом направлении и на одну клетку по горизонтали,
или наоборот. Даны две различные клетки шахматной доски, определите, может ли конь попасть с первой клетки на вторую
одним ходом.


• Обработайте все исключения, которые могут встретиться в программе.


# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

Выполните следующие задания:

Функция plus_two() выполняет одну простую задачу — выводит результат сложения переданного в нее числа 2 и значения
переменной number.
В переменную number должно быть передано число. 
Обработайте ситуацию, если в эту переменную переданы данные какого-то другого типа. 
В случае ошибки напечатайте в консоли сообщение «Ожидаемый тип данных — число!».

Запустите код и проверьте работу кода в консоли.

Подсказка:
Используйте конструкцию try/except.
В процессе поиска решения попробуйте вывести в консоль сумму строки и числа, изучите сообщение об ошибке.
В Python есть специальное исключение для ситуации, если тип переданного значения не соответствует ожиданиям.

# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

Выполните следующие задания:

Задание №1

Напишите программу, которая позволяет получить доступ к элементу массива, индекс которого выходит за границы,
и обработаем соответствующее исключение.
'''
'''
Решения:
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
class InvalidCoordinateError(Exception):
    pass

class InvalidPieceError(Exception):
    pass

class ChessPiece:
    def __init__(self, row, col):
        if not (1 <= row <= 8 and 1 <= col <= 8):
            raise InvalidCoordinateError("Координаты должны быть в интервале от 1 до 8")
        self.row = row
        self.col = col

    def can_move(self, other):
        raise NotImplementedError("Метод должен быть переопределен в подклассе")

class Rook(ChessPiece):
    def can_move(self, other):
        return self.row == other.row or self.col == other.col

class Knight(ChessPiece):
    def can_move(self, other):
        return (abs(self.row - other.row) == 2 and abs(self.col - other.col) == 1) or \
               (abs(self.row - other.row) == 1 and abs(self.col - other.col) == 2)

class Bishop(ChessPiece):
    def can_move(self, other):
        return abs(self.row - other.row) == abs(self.col - other.col)

class Queen(ChessPiece):
    def can_move(self, other):
        return self.row == other.row or self.col == other.col or abs(self.row - other.row) == abs(self.col - other.col)

class King(ChessPiece):
    def can_move(self, other):
        return abs(self.row - other.row) <= 1 and abs(self.col - other.col) <= 1

class Pawn(ChessPiece):
    def can_move(self, other):
        # Это очень упрощенный вариант для пешки, не учитывающий правила первого хода и взятия на проходе
        return abs(self.row - other.row) == 1 and abs(self.col - other.col) == 1

def get_position():
    try:
        row = int(input("Введите номер строки (1-8): "))
        col = int(input("Введите номер столбца (1-8): "))
        if not (1 <= row <= 8 and 1 <= col <= 8):
            raise InvalidCoordinateError("Некорректные координаты.")
        return row, col
    except ValueError:
        raise InvalidCoordinateError("Некорректные координаты.")

try:
    piece_type = input("Выберите фигуру (ладья/конь/слон/ферзь/король/пешка): ").lower()
    if piece_type not in ('ладья', 'конь', 'слон', 'ферзь', 'король', 'пешка'):
        raise InvalidPieceError("Выберите корректную фигуру (ладья/конь/слон/ферзь/король/пешка)")

    print(f"{piece_type.capitalize()}:")
    piece_position1 = get_position()
    piece_position2 = get_position()

    piece1 = None
    piece2 = None

    if piece_type == 'ладья':
        piece1 = Rook(piece_position1[0], piece_position1[1])
        piece2 = Rook(piece_position2[0], piece_position2[1])
    elif piece_type == 'конь':
        piece1 = Knight(piece_position1[0], piece_position1[1])
        piece2 = Knight(piece_position2[0], piece_position2[1])
    elif piece_type == 'слон':
        piece1 = Bishop(piece_position1[0], piece_position1[1])
        piece2 = Bishop(piece_position2[0], piece_position2[1])
    elif piece_type == 'ферзь':
        piece1 = Queen(piece_position1[0], piece_position1[1])
        piece2 = Queen(piece_position2[0], piece_position2[1])
    elif piece_type == 'король':
        piece1 = King(piece_position1[0], piece_position1[1])
        piece2 = King(piece_position2[0], piece_position2[1])
    elif piece_type == 'пешка':
        piece1 = Pawn(piece_position1[0], piece_position1[1])
        piece2 = Pawn(piece_position2[0], piece_position2[1])

    if piece1.can_move(piece2):
        print(f"{piece_type.capitalize()} может попасть с первой клетки на вторую одним ходом.")
    else:
        print(f"{piece_type.capitalize()} не может попасть с первой клетки на вторую одним ходом.")

except KeyboardInterrupt:
    print("\nПрограмма завершена.")
except (InvalidCoordinateError, InvalidPieceError) as e:
    print(f"Ошибка: {e}")
except Exception as e:
    print(f"Ошибка: {e}")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
1. Создание исключений
'''
class InvalidCoordinateError(Exception):
    pass

class InvalidPieceError(Exception):
    pass
'''
Эти строки создают два новых типа исключений, InvalidCoordinateError и InvalidPieceError. 
Исключения используются для обработки ситуаций, когда происходит что-то неожиданное или недопустимое 
в ходе выполнения программы.
'''
'''
2. Определение базового класса ChessPiece
'''
class ChessPiece:
    def __init__(self, row, col):
        if not (1 <= row <= 8 and 1 <= col <= 8):
            raise InvalidCoordinateError("Координаты должны быть в интервале от 1 до 8")
        self.row = row
        self.col = col

    def can_move(self, other):
        raise NotImplementedError("Метод должен быть переопределен в подклассе")
'''
Этот класс представляет базовую шахматную фигуру. Конструктор (__init__) проверяет допустимость координат и 
инициализирует атрибуты row и col. Метод can_move является абстрактным и должен быть переопределен в каждом подклассе.
'''
'''
3. Определение подклассов фигур (ладья, конь, слон, ферзь, король, пешка)
'''
class Rook(ChessPiece):
    def can_move(self, other):
        return self.row == other.row or self.col == other.col

class Knight(ChessPiece):
    def can_move(self, other):
        return (abs(self.row - other.row) == 2 and abs(self.col - other.col) == 1) or \
               (abs(self.row - other.row) == 1 and abs(self.col - other.col) == 2)
'''
Эти подклассы представляют конкретные фигуры. Каждый из них реализует метод can_move в 
соответствии с правилами движения своей фигуры.
'''
'''
4. Ввод координат с проверкой валидности
'''
def get_position():
    try:
        row = int(input("Введите номер строки (1-8): "))
        col = int(input("Введите номер столбца (1-8): "))
        if not (1 <= row <= 8 and 1 <= col <= 8):
            raise InvalidCoordinateError("Некорректные координаты.")
        return row, col
    except ValueError:
        raise InvalidCoordinateError("Некорректные координаты.")
'''
Эта функция запрашивает у пользователя ввод координат и проверяет их на валидность. 
Если ввод не соответствует ожидаемому формату или выходит за пределы шахматной доски, возбуждается
исключение InvalidCoordinateError.
'''
'''
5. Основной блок программы
'''
try:
    piece_type = input("Выберите фигуру (ладья/конь/слон/ферзь/король/пешка): ").lower()
    if piece_type not in ('ладья', 'конь', 'слон', 'ферзь', 'король', 'пешка'):
        raise ValueError("Выберите корректную фигуру (ладья/конь/слон/ферзь/король/пешка)")

    print(f"{piece_type.capitalize()}:")
    piece_position1 = get_position()
    piece_position2 = get_position()

    piece1 = None
    piece2 = None

    if piece_type == 'ладья':
        piece1 = Rook(piece_position1[0], piece_position1[1])
        piece2 = Rook(piece_position2[0], piece_position2[1])
    # ... (аналогично для других фигур)

    if piece1.can_move(piece2):
        print(f"{piece_type.capitalize()} может попасть с первой клетки на вторую одним ходом.")
    else:
        print(f"{piece_type.capitalize()} не может попасть с первой клетки на вторую одним ходом.")

except KeyboardInterrupt:
    print("\nПрограмма завершена.")
except (InvalidCoordinateError, InvalidPieceError) as e:
    print(f"Ошибка: {e}")
except Exception as e:
    print(f"Ошибка: {e}")
'''
            1. Получение выбора фигуры от пользователя
'''
piece_type = input("Выберите фигуру (ладья/конь/слон/ферзь/король/пешка): ").lower()
'''
Эта строка запрашивает у пользователя ввод типа фигуры, которую он хочет использовать. lower() используется для
приведения введенного текста к нижнему регистру.
'''
'''
            2. Проверка корректности выбора фигуры
'''
if piece_type not in ('ладья', 'конь', 'слон', 'ферзь', 'король', 'пешка'):
    raise ValueError("Выберите корректную фигуру (ладья/конь/слон/ферзь/король/пешка)")
'''
Здесь проверяется, что введенный тип фигуры находится среди допустимых. 
В случае ошибки генерируется исключение ValueError.
'''
'''
            3. Ввод координат для первой и второй клеток
'''
print(f"{piece_type.capitalize()}:")
piece_position1 = get_position()
piece_position2 = get_position()
'''
Программа выводит название выбранной фигуры с заглавной буквы и запрашивает у пользователя координаты двух клеток.
'''
'''
            4. Создание объектов фигур
'''
piece1 = None
piece2 = None

if piece_type == 'ладья':
    piece1 = Rook(piece_position1[0], piece_position1[1])
    piece2 = Rook(piece_position2[0], piece_position2[1])
# ... (аналогично для других фигур)
'''
В зависимости от выбранного типа фигуры создаются объекты соответствующих классов (Rook, Knight, и так далее)
с использованием введенных координат.
'''
'''
            5. Проверка возможности хода фигуры
'''
if piece1.can_move(piece2):
    print(f"{piece_type.capitalize()} может попасть с первой клетки на вторую одним ходом.")
else:
    print(f"{piece_type.capitalize()} не может попасть с первой клетки на вторую одним ходом.")
'''
После создания объектов фигур вызывается метод can_move для первой фигуры, чтобы проверить,
может ли она сделать ход на вторую клетку. Результат выводится пользователю.
'''
'''
            6. Обработка исключений
'''
except KeyboardInterrupt:
    print("\nПрограмма завершена.")
except (InvalidCoordinateError, InvalidPieceError) as e:
    print(f"Ошибка: {e}")
except Exception as e:
    print(f"Ошибка: {e}")

'''
Данный блок обрабатывает различные исключения.
Если пользователь прерывает программу (Ctrl+C),
выводится соответствующее сообщение. 
Если возникает ошибка связанная с некорректными координатами или фигурой,
программа сообщает об ошибке. 
Исключения, не связанные с некорректными данными, 
обрабатываются в блоке except Exception as e.
'''
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

Выполните следующие задания:

Функция plus_two() выполняет одну простую задачу — выводит результат сложения переданного в нее числа 2 и значения
переменной number.
В переменную number должно быть передано число. 
Обработайте ситуацию, если в эту переменную переданы данные какого-то другого типа. 
В случае ошибки напечатайте в консоли сообщение «Ожидаемый тип данных — число!».

Запустите код и проверьте работу кода в консоли.

Подсказка:
Используйте конструкцию try/except.
В процессе поиска решения попробуйте вывести в консоль сумму строки и числа, изучите сообщение об ошибке.
В Python есть специальное исключение для ситуации, если тип переданного значения не соответствует ожиданиям.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
Этот код запрашивает у пользователя ввод числа, пытается выполнить сложение с числом 2, 
и в случае ошибки (если введенные данные не являются числом) выводит соответствующее сообщение об ошибке.
'''
# Определение функции plus_two(), которая принимает на вход число и выводит результат сложения числа и 2.
def plus_two(number):
    return number + 2
try:
    # Запрос у пользователя ввода числа и преобразование введенной строки в целое число.
    number = int(input("Введите число: "))
    # Вызов функции plus_two() с введенным числом.
    result = plus_two(number)
    # Вывод результата сложения.
    print(f"Результат сложения {number} + 2: {result}")
except ValueError:
    # Обработка исключения ValueError, которое возникает, если введенные данные не могут быть преобразованы в число.
    print("Ожидаемый тип данных — число!")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
1. def plus_two(number): 
Эта строка определяет функцию plus_two, которая принимает один аргумент number. 
Функция возвращает сумму переданного числа и 2.


2. return number + 2: 
Эта строка внутри функции plus_two возвращает результат сложения переданного числа и 2.

3. try: 
Начало блока try, который используется для выполнения кода, который может вызвать исключение.

4. number = int(input("Введите число: ")): 
Запрос у пользователя ввода числа с использованием input(). 
Введенная строка преобразуется в целое число с помощью int() и сохраняется в переменной number.

5. result = plus_two(number): Вызов функции plus_two с введенным числом, и результат сохраняется в переменной result.

6. print(f"Результат сложения {number} + 2: {result}"): 
Вывод результата сложения в форматированной строке.

7. except ValueError: 
Начало блока except, который выполняется, если произошло исключение типа ValueError.

8. print("Ожидаемый тип данных — число!"): 
Вывод сообщения об ошибке в случае, если введенные данные не могут быть преобразованы в число.
'''
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
Обработка исключений
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #

Выполните следующие задания:

Задание №1

Напишите программу, которая позволяет получить доступ к элементу массива, индекс которого выходит за границы,
и обработаем соответствующее исключение.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
try:
    # Создаем массив чисел
    numbers = [1, 2, 3, 4, 5]

    # Пользователь вводит индекс
    index = int(input("Введите индекс элемента: "))

    # Пытаемся получить доступ к элементу массива по введенному индексу
    element = numbers[index]

    # Выводим результат
    print(f"Элемент с индексом {index}: {element}")

except IndexError:
    # Обрабатываем исключение IndexError, которое возникает при попытке обращения к индексу за границами массива
    print("Индекс выходит за границы массива!")

except ValueError:
    # Обрабатываем исключение ValueError, которое возникает при попытке преобразовать введенную строку в целое число
    print("Введите корректный индекс (целое число)!")
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
'''
В этом коде:
1. Я создаю самый простой массив из numbers.
2. Пользователь со своей стороны вводит индекс.
3. Затем в блоке try мы пытаемся получить доступ к элементу массива по введенному индексу.
4. Если индекс выходит за границы массива, возникает исключение IndexError,
и мы его перехватываем в блоке except IndexError.
5. Если введенная строка не может быть преобразована в целое число, возникает исключение ValueError,
и мы его перехватываем в блоке except ValueError.
6. И на конец в случае успешного доступа к элементу, мы выводим результат.
'''
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
# ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ #
